---
title: "gdp_distribution"
output: html_document
date: "2023-08-09"
---
```{r}
library(dplyr)
library(stats)
library(tidyr)
library(purrr)
library(tsibble)
library(forecast)
library(maxLik)
library(stats4)
library(moments)
library(univariateML)
```

```{r}
library(readxl)
ip <-read_excel("DP_LIVE_09082023174326289.xlsx",col_types = c("text", "text", "text", 
         "text", "text", "text", "numeric", 
         "skip"))
View(ip)
usGDPC1_1_ <- read_excel("GDPC1 (1).xlsx")
View(usGDPC1_1_)
```
```{r}
options(scipen = 999)
```

```{r}
ip <- ip %>%
  group_by(LOCATION) %>%
  mutate(growthrate = (Value - dplyr::lag(Value, 1)) / dplyr::lag(Value, 1))

usGDPC1_1_=usGDPC1_1_ %>%
  mutate(growthrate = ( realgdp- dplyr::lag(realgdp, 1)) / dplyr::lag(realgdp, 1))

```
```{r}
ip <- ip %>%
  mutate(TIME = yearmonth(TIME))

ip_ts <- ip %>%
  group_by(LOCATION) %>%
  slice(-1) %>%
  as_tsibble(key = "LOCATION", index = "TIME")
usGDPC1_1_ts <- usGDPC1_1_ %>%
  mutate(observation_date = as.Date(observation_date)) %>%
  as_tsibble(index = "observation_date", regular = TRUE)


```



```{r}
calculate_acf_with_leads <- function(series, lag.max = 6, lead.max = 6) {
  # Remove missing values
  series <- na.omit(series)
  
  # Calculate ACF for lags
  acf_lags <- acf(series, lag.max = lag.max, plot = FALSE)$acf
  
  # Calculate ACF for leads (by reversing the series and calculating lags)
  acf_leads <- rev(acf(series[length(series):1], lag.max = lead.max, plot = FALSE)$acf)
  
  # Combine results, excluding the 0 lag from acf_lags as it's already included in acf_leads
  combined_acf <- c(acf_leads, acf_lags[-1])
  
  return(combined_acf)
}
```


```{r}
lag_max = 6
 lead_max = 6
 
 # Calculate average growth rate by location and time
 average_growthrate_by_location <- ip_ts %>%
     index_by(TIME) %>%
     summarize(growthrate = mean(growthrate, na.rm = TRUE), .groups = "drop")
# Apply the calculate_acf_with_leads function to the averaged series
 acf_with_leads_series1 <- calculate_acf_with_leads(average_growthrate_by_location$growthrate, lag.max = lag_max, lead.max = lead_max)
 
 # Apply the function to the other series
 acf_with_leads_series2 <- calculate_acf_with_leads(usGDPC1_1_ts$growthrate, lag.max = lag_max, lead.max = lead_max)
 
# Define the lags and leads
 lags_and_leads <- (-lead_max:lag_max)
 
 # Plot the results for series 1
 plot(lags_and_leads, acf_with_leads_series1, type = "l", ylim = c(-1, 1), main = "Comparison of Two Autocorrelations", xlab = "Lag/Lead", ylab = "ACF", col = "black")
 
 # Add the line for series 2
 lines(lags_and_leads, acf_with_leads_series2, col = "red")
 
 # Add a legend
 legend("topright", legend = c("ip oecd", "usgdpgrowthrate"), col = c("black", "red"), lty = 1)
 


```
```{r}
#turn to list to get ready for mle
usgdp_list=usGDPC1_1_%>%drop_na%>%as.list(usGDPC1_1_$growthrate)


```
```{r}
#use simple mle to get rough estimates 
dlaplace_standard <- function(x, mu = 0, a = 1) {
  if (a <= 0) return(NA)
  (1 / (2 * a)) * exp(1)^(-abs(x - mu) / a)
}

fit_standard <- MASS::fitdistr(usgdp_list$growthrate, dlaplace_standard, start = list(mu = 0, a = 1))
print(fit_standard)



```



```{r}
dlaplace_modified <- function(x, m, a, b) {
  if(a <= 0 || b <= 0) return(NA)
  
  gamma_val <- gamma(1 + 1/b)
  part1 <- 1 / (2 * a * b^(1/b) * gamma_val)
  part2 <- exp((-1/b) * abs((x - m) / a)^b)
  
  result <- part1 * part2
  return(result)
}


```


```{r}


#usgdpgrowthrate <- # your data here
fit <- MASS::fitdistr(usgdp_list$growthrate, dlaplace_modified, start = list(m = .5 ,a=1 ,b =.7 ))
print(fit)


```

```{r}



# Function to estimate b from data
estimate_b <- function(data) {
    fit <- MASS::fitdistr(data, dlaplace_modified, start = list(m = fit$estimate['m'], a = fit$estimate['a'], b = fit$estimate['b']))
    return(fit$estimate['b'])
}

# Bootstrap
bootstrap_b <- replicate(4000, {
    sample_data <- sample(usgdp_list$growthrate, size = length(original_data), replace = TRUE)
    estimate_b(sample_data)
})
#only a d Small samples give Gaussian curves 
length(which(bootstrap_b>=2))
```
```{r}
# Perform a two-tailed t-test to test whether the mean of bootstrap_b is 1
 t.test(bootstrap_b, alternative = "two.sided", mu = 1)
#use ttest to see if b could be 2 which would be a normal distribution 
 t.test(bootstrap_b, alternative = "less", mu = 2)

```
```{r}
library(moments)
```
```{r}
#test for skewness 
agostino.test(usgdp_list$growthrate,alternative = "two.sided")
#we can't reject the null so we can have confidence that the skew is marginal 
```

```{r}

pdf_plot <- ggplot(plot_data, aes(x = x_values, y = log(pdf_values))) +
  geom_line(color = 'blue', linewidth = 2) + # Change here
  geom_point(data = data.frame(x = usgdp_list$growthrate, y = rep(0, length(usgdp_list$growthrate))), aes(x = x, y = y), color = 'red') +
  xlab('Growth Rates') +
  ylab('Log Density') +
  ggtitle('PDF of Modified Laplace Distribution') +
  theme_minimal()

# Printing the plot
print(pdf_plot)

```
```{r}

# Step 1: Define the CDF for the modified Laplace distribution
plaplace_modified <- function(x, m, a, b) {
  sapply(x, function(x_i) {
    integrate(function(u) dlaplace_modified(u, m, a, b), -Inf, x_i)$value
  })
}

# Step 2: Create a custom function capturing the parameters
custom_cdf <- function(x) {
  plaplace_modified(x, m = fit$estimate['m'], a = fit$estimate['a'], b = fit$estimate['b'])
}

# Step 3: Perform the KS test
ks_result <- ks.test(usgdp_list$growthrate, custom_cdf)

# Print the result
print(ks_result)

```

```{r}


# The CDF for the Kuiper test
cdf_func <- function(x) plaplace_modified(x, fit$estimate["m"], fit$estimate["a"], fit$estimate["b"])

# Applying the Kuiper test
kuiper_result <- ks.test(usgdp_list$growthrate, cdf_func)

# Print the result
print(kuiper_result)

```



